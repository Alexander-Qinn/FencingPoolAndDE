<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Fencing Pool + DE Builder</title>
    <style>
      :root {
        --bg: #f3f5fa;
        --panel: #ffffff;
        --muted: #5c667a;
        --text: #1b1f2a;
        --accent: #2d5be3;
        --border: #cdd3df;
        --good: #1c9f67;
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        background: var(--bg);
        color: var(--text);
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      }
      header {
        padding: 20px 16px 10px;
        border-bottom: 2px solid var(--border);
        background: #f9faff;
      }
      h1 {
        margin: 0 0 6px;
        font-size: 22px;
        font-weight: 700;
      }
      p {
        margin: 4px 0;
        color: var(--muted);
        font-size: 13px;
      }
      main {
        padding: 16px;
        display: grid;
        gap: 16px;
      }
      .panel {
        background: var(--panel);
        border: 1px solid var(--border);
        border-radius: 10px;
        padding: 14px;
      }
      .panel h2 {
        margin: 0 0 10px;
        font-size: 16px;
      }
      label {
        display: block;
        font-size: 12px;
        color: var(--muted);
        margin-bottom: 6px;
      }
      textarea,
      input,
      select,
      button {
        width: 100%;
        border-radius: 8px;
        border: 1px solid var(--border);
        background: #ffffff;
        color: var(--text);
        padding: 8px 10px;
        font-size: 14px;
      }
      textarea {
        min-height: 120px;
        resize: vertical;
      }
      .row {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 10px;
      }
      .hint {
        font-size: 12px;
        color: var(--muted);
        margin-top: 6px;
      }
      .warning {
        color: #ffb14f;
        font-size: 12px;
        margin-top: 6px;
      }
      table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 8px;
      }
      th,
      td {
        border: 1px solid var(--border);
        padding: 6px 6px;
        text-align: center;
        font-size: 12px;
      }
      th {
        background: #f2f4f8;
        font-weight: 600;
        color: var(--muted);
      }
      .pool-card {
        border: 1px solid var(--border);
        border-radius: 10px;
        padding: 10px;
        margin-bottom: 12px;
      }
      .pool-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
      }
      .badge {
        background: #eef2ff;
        color: #2d3a68;
        font-size: 12px;
        padding: 2px 8px;
        border-radius: 999px;
      }
      .bout-row {
        display: grid;
        grid-template-columns: 1fr 64px 64px;
        gap: 6px;
        align-items: center;
        margin-bottom: 6px;
      }
      .bout-row input {
        text-align: center;
      }
      .bout-row span {
        font-size: 12px;
      }
      .inline {
        display: flex;
        gap: 8px;
        align-items: center;
      }
      .inline input[type="checkbox"] {
        width: auto;
      }
      .good {
        color: var(--good);
        font-weight: 600;
      }
      .grid-wrap {
        overflow-x: auto;
      }
      .muted {
        color: var(--muted);
      }
      .sheet-header {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 10px;
      }
      .sheet-field label {
        font-size: 11px;
        text-transform: uppercase;
        letter-spacing: 0.04em;
      }
      .sheet-field input {
        border-radius: 0;
        border: none;
        border-bottom: 2px solid var(--border);
        padding: 6px 2px;
        background: transparent;
      }
      .sheet-table th,
      .sheet-table td {
        font-size: 11px;
        padding: 4px;
      }
      .sheet-table input {
        width: 44px;
        border-radius: 6px;
        padding: 4px 6px;
        font-size: 12px;
        text-align: center;
      }
      .sheet-table .diag {
        color: var(--muted);
        font-size: 11px;
      }
      .sheet-subhead {
        display: flex;
        justify-content: space-between;
        align-items: baseline;
        gap: 10px;
        margin-bottom: 8px;
      }
      .de-rounds {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 12px;
      }
      .de-round {
        border: 1px solid var(--border);
        border-radius: 8px;
        padding: 8px;
        background: #fbfcff;
      }
      .de-round h4 {
        margin: 0 0 8px;
        font-size: 13px;
        color: var(--muted);
      }
      .de-match {
        display: grid;
        grid-template-columns: 1fr 54px 54px 1fr;
        gap: 6px;
        align-items: center;
        margin-bottom: 6px;
      }
      .de-match input {
        text-align: center;
      }
      .de-seed {
        color: var(--muted);
        font-size: 11px;
        margin-right: 4px;
      }
      .de-winner {
        font-weight: 600;
        color: var(--good);
      }
    </style>
  </head>
  <body>
    <header>
      <h1>Fencing Pool + DE Builder</h1>
      <p>Frontend-only pool + DE sheets with bout order, calculations, and seeding.</p>
    </header>
    <main id="root"></main>

    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script type="text/babel">
      const { useMemo, useState, useEffect } = React;

      const DEFAULT_BOUT_ORDER = {
        4: [
          [1, 4],
          [2, 3],
          [1, 3],
          [2, 4],
          [3, 4],
          [1, 2],
        ],
        5: [
          [1, 2],
          [3, 4],
          [5, 1],
          [2, 3],
          [5, 4],
          [1, 3],
          [2, 5],
          [4, 1],
          [3, 5],
          [4, 2],
        ],
        6: [
          [1, 4],
          [2, 5],
          [3, 6],
          [1, 2],
          [3, 5],
          [4, 6],
          [2, 3],
          [1, 5],
          [4, 2],
          [6, 1],
          [3, 4],
          [5, 6],
          [2, 6],
          [3, 1],
          [4, 5],
        ],
        7: [
          [1, 4],
          [2, 5],
          [3, 6],
          [7, 1],
          [4, 5],
          [2, 6],
          [3, 7],
          [1, 5],
          [4, 6],
          [2, 7],
          [3, 1],
          [5, 6],
          [4, 7],
          [1, 2],
          [3, 5],
          [6, 7],
          [2, 4],
          [1, 6],
          [5, 7],
          [3, 4],
          [2, 3],
        ],
        8: [
          [1, 5],
          [2, 6],
          [3, 7],
          [4, 8],
          [1, 2],
          [3, 4],
          [5, 6],
          [7, 8],
          [1, 3],
          [2, 4],
          [5, 7],
          [6, 8],
          [1, 4],
          [2, 3],
          [5, 8],
          [6, 7],
          [1, 6],
          [2, 5],
          [3, 8],
          [4, 7],
          [1, 7],
          [2, 8],
          [3, 5],
          [4, 6],
          [1, 8],
          [2, 7],
          [3, 6],
          [4, 5],
        ],
      };

      const nextPowerOfTwo = (n) => {
        let p = 1;
        while (p < n) p *= 2;
        return p;
      };

      const parseFencers = (text) =>
        text
          .split("\n")
          .map((line) => line.trim())
          .filter(Boolean)
          .map((line, idx) => {
            let name = line;
            let club = "";
            if (line.includes("|")) {
              const [left, right] = line.split("|").map((part) => part.trim());
              name = left || `Fencer ${idx + 1}`;
              club = right || "";
            } else if (line.includes(",")) {
              const [left, right] = line.split(",").map((part) => part.trim());
              name = left || `Fencer ${idx + 1}`;
              club = right || "";
            } else if (line.includes("\t")) {
              const [left, right] = line.split("\t").map((part) => part.trim());
              name = left || `Fencer ${idx + 1}`;
              club = right || "";
            }
            return { id: `f${idx + 1}`, seed: idx + 1, name, club };
          });

      const snakePools = (fencers, poolSize) => {
        if (!fencers.length) return [];
        const poolCount = Math.ceil(fencers.length / poolSize);
        const pools = Array.from({ length: poolCount }, (_, i) => ({
          id: `pool-${i + 1}`,
          label: `Pool ${i + 1}`,
          fencers: [],
        }));
        fencers.forEach((fencer, index) => {
          const row = Math.floor(index / poolCount);
          const posInRow = index % poolCount;
          const poolIndex = row % 2 === 0 ? posInRow : poolCount - 1 - posInRow;
          pools[poolIndex].fencers.push(fencer);
        });
        return pools;
      };

      const parseCustomOrder = (text) =>
        text
          .split("\n")
          .map((line) => line.trim())
          .filter(Boolean)
          .map((line) => {
            const cleaned = line.replace(/[^\d-]/g, "");
            const [a, b] = cleaned.split("-").map((n) => Number(n));
            return Number.isFinite(a) && Number.isFinite(b) ? [a, b] : null;
          })
          .filter(Boolean);

      const buildBoutOrder = (size, customPairs) => {
        if (customPairs && customPairs.length === (size * (size - 1)) / 2) {
          return customPairs;
        }
        return DEFAULT_BOUT_ORDER[size] || [];
      };

      const getScoreKey = (poolId, rowIndex, colIndex) =>
        `${poolId}-${rowIndex}-${colIndex}`;

      const readScore = (value) => {
        if (value === null || value === undefined) return null;
        const str = String(value).trim();
        if (!str) return null;
        const parsed = Number(str);
        return Number.isFinite(parsed) ? parsed : null;
      };

      const computePoolStats = (pool, scores) => {
        const stats = pool.fencers.map((fencer, idx) => ({
          ...fencer,
          index: idx + 1,
          wins: 0,
          ts: 0,
          tr: 0,
          bouts: 0,
        }));
        const byIndex = Object.fromEntries(stats.map((f) => [f.index, f]));

        for (let i = 1; i <= pool.fencers.length; i += 1) {
          for (let j = i + 1; j <= pool.fencers.length; j += 1) {
            const aScore = readScore(scores[getScoreKey(pool.id, i, j)]);
            const bScore = readScore(scores[getScoreKey(pool.id, j, i)]);
            if (aScore === null || bScore === null) continue;
            const a = byIndex[i];
            const b = byIndex[j];
            if (!a || !b) continue;
            a.ts += aScore;
            a.tr += bScore;
            b.ts += bScore;
            b.tr += aScore;
            a.bouts += 1;
            b.bouts += 1;
            if (aScore > bScore) a.wins += 1;
            if (bScore > aScore) b.wins += 1;
          }
        }

        return stats.map((f) => ({
          ...f,
          ind: f.ts - f.tr,
          winPct: f.bouts ? f.wins / f.bouts : 0,
        }));
      };

      const buildDeSeedings = (poolStats, promotionPct) => {
        const promotedCount = Math.ceil((poolStats.length * promotionPct) / 100);
        const sorted = [...poolStats].sort((a, b) => {
          if (b.winPct !== a.winPct) return b.winPct - a.winPct;
          if (b.ind !== a.ind) return b.ind - a.ind;
          if (b.ts !== a.ts) return b.ts - a.ts;
          return a.name.localeCompare(b.name);
        });
        return sorted.slice(0, promotedCount).map((f, idx) => ({
          ...f,
          deSeed: idx + 1,
        }));
      };

      const getMatchKey = (matchId, side) => `${matchId}-${side}`;

      const getWinner = (match, results) => {
        const aScore = readScore(results[getMatchKey(match.id, "a")]);
        const bScore = readScore(results[getMatchKey(match.id, "b")]);
        if (!match.slotA && !match.slotB) return null;
        if (match.slotA && !match.slotB) return match.slotA;
        if (!match.slotA && match.slotB) return match.slotB;
        if (aScore === null || bScore === null) return null;
        if (aScore > bScore) return match.slotA;
        if (bScore > aScore) return match.slotB;
        return null;
      };

      const buildDeRounds = (seedings, results) => {
        const size = nextPowerOfTwo(seedings.length);
        const getSeed = (seed) => seedings.find((f) => f.deSeed === seed);
        const firstMatches = [];
        for (let seed = 1; seed <= size / 2; seed += 1) {
          const opponentSeed = size + 1 - seed;
          const a = getSeed(seed);
          const b = getSeed(opponentSeed);
          firstMatches.push({
            id: `r${size}-m${seed}`,
            roundSize: size,
            slotA: a ? { name: a.name, seed: a.deSeed } : null,
            slotB: b ? { name: b.name, seed: b.deSeed } : null,
          });
        }
        const rounds = [{ roundSize: size, matches: firstMatches }];
        let currentSize = size;
        while (currentSize > 2) {
          const prev = rounds[rounds.length - 1];
          const nextSize = currentSize / 2;
          const nextMatches = [];
          for (let i = 0; i < prev.matches.length; i += 2) {
            const leftMatch = prev.matches[i];
            const rightMatch = prev.matches[i + 1];
            const winnerA = getWinner(leftMatch, results);
            const winnerB = getWinner(rightMatch, results);
            nextMatches.push({
              id: `r${nextSize}-m${i / 2 + 1}`,
              roundSize: nextSize,
              slotA: winnerA
                ? winnerA
                : {
                    name: `Winner R${leftMatch.roundSize} M${i + 1}`,
                    seed: null,
                  },
              slotB: winnerB
                ? winnerB
                : {
                    name: `Winner R${rightMatch.roundSize} M${i + 2}`,
                    seed: null,
                  },
            });
          }
          rounds.push({ roundSize: nextSize, matches: nextMatches });
          currentSize = nextSize;
        }
        return rounds;
      };

      const App = () => {
        const [fencerText, setFencerText] = useState("");
        const [poolSize, setPoolSize] = useState(7);
        const [promotionPct, setPromotionPct] = useState(100);
        const [useCustomOrder, setUseCustomOrder] = useState(false);
        const [customOrderText, setCustomOrderText] = useState("");
        const [scores, setScores] = useState({});
        const [sheetInfo, setSheetInfo] = useState({
          tournament: "",
          competition: "",
          round: "",
          poolLabel: "",
          strip: "",
          referee: "",
        });
        const [deResults, setDeResults] = useState({});

        const fencers = useMemo(() => parseFencers(fencerText), [fencerText]);
        const pools = useMemo(() => snakePools(fencers, poolSize), [fencers, poolSize]);
        const customOrder = useMemo(
          () => (useCustomOrder ? parseCustomOrder(customOrderText) : null),
          [useCustomOrder, customOrderText]
        );

        useEffect(() => {
          const nextScores = {};
          pools.forEach((pool) => {
            for (let i = 1; i <= pool.fencers.length; i += 1) {
              for (let j = 1; j <= pool.fencers.length; j += 1) {
                if (i === j) continue;
                nextScores[getScoreKey(pool.id, i, j)] = "";
              }
            }
          });
          setScores((prev) => ({ ...nextScores, ...prev }));
        }, [pools]);


        const poolSummaries = pools.map((pool) => {
          const bouts = buildBoutOrder(pool.fencers.length, customOrder);
          const stats = computePoolStats(pool, scores);
          return { pool, bouts, stats };
        });

        const allStats = poolSummaries.flatMap((summary) => summary.stats);
        const seedings = buildDeSeedings(allStats, promotionPct);
        const deRounds = buildDeRounds(seedings, deResults);

        useEffect(() => {
          setDeResults({});
        }, [seedings.length]);

        const customOrderExpected =
          poolSize && (poolSize * (poolSize - 1)) / 2;
        const customOrderValid =
          customOrder && customOrder.length === customOrderExpected;

        return (
          <>
            <section className="panel">
              <h2>Fencers</h2>
              <label>One per line. Use "Name | Club" or "Name, Club".</label>
              <textarea
                value={fencerText}
                placeholder={"Alex Smith | Club A\nJamie Lee | Club B"}
                onChange={(e) => setFencerText(e.target.value)}
              />
              <p className="hint">
                Seed order is the input order. Pools use snake placement.
              </p>
            </section>

            <section className="panel">
              <h2>Pool Settings</h2>
              <div className="row">
                <div>
                  <label>Pool size</label>
                  <select
                    value={poolSize}
                    onChange={(e) => setPoolSize(Number(e.target.value))}
                  >
                    {[4, 5, 6, 7, 8].map((size) => (
                      <option key={size} value={size}>
                        {size}
                      </option>
                    ))}
                  </select>
                </div>
                <div>
                  <label>Promotion to DE</label>
                  <select
                    value={promotionPct}
                    onChange={(e) => setPromotionPct(Number(e.target.value))}
                  >
                    <option value={100}>100% (local + most events)</option>
                    <option value={80}>80% (some national events)</option>
                  </select>
                </div>
              </div>
              <div className="inline" style={{ marginTop: "10px" }}>
                <input
                  type="checkbox"
                  checked={useCustomOrder}
                  onChange={(e) => setUseCustomOrder(e.target.checked)}
                />
                <label style={{ margin: 0 }}>
                  Use custom bout order for current pool size
                </label>
              </div>
              {useCustomOrder ? (
                <>
                  <textarea
                    value={customOrderText}
                    placeholder={"1-4\n2-3\n1-3\n2-4\n3-4\n1-2"}
                    onChange={(e) => setCustomOrderText(e.target.value)}
                  />
                  <p className="hint">
                    Expected {customOrderExpected} bouts for pool size {poolSize}.
                  </p>
                  {!customOrderValid && (
                    <p className="warning">
                      Custom order ignored until it matches the expected count.
                    </p>
                  )}
                </>
              ) : (
                <p className="hint">
                  Default order is based on the USA Fencing pool sheet (2019
                  revision).
                </p>
              )}
            </section>

            <section className="panel">
              <h2>Pools</h2>
              {pools.length === 0 && (
                <p className="muted">Add fencers to generate pools.</p>
              )}
              {poolSummaries.map(({ pool, bouts, stats }) => (
                <div key={pool.id} className="pool-card">
                  <div className="pool-header">
                    <strong>{pool.label}</strong>
                    <span className="badge">{pool.fencers.length} fencers</span>
                  </div>

                  <div className="sheet-header" style={{ marginBottom: "10px" }}>
                    <div className="sheet-field">
                      <label>Tournament</label>
                      <input
                        value={sheetInfo.tournament}
                        onChange={(e) =>
                          setSheetInfo((prev) => ({
                            ...prev,
                            tournament: e.target.value,
                          }))
                        }
                      />
                    </div>
                    <div className="sheet-field">
                      <label>Competition</label>
                      <input
                        value={sheetInfo.competition}
                        onChange={(e) =>
                          setSheetInfo((prev) => ({
                            ...prev,
                            competition: e.target.value,
                          }))
                        }
                      />
                    </div>
                    <div className="sheet-field">
                      <label>Round</label>
                      <input
                        value={sheetInfo.round}
                        onChange={(e) =>
                          setSheetInfo((prev) => ({
                            ...prev,
                            round: e.target.value,
                          }))
                        }
                      />
                    </div>
                    <div className="sheet-field">
                      <label>Pool</label>
                      <input value={pool.label} readOnly />
                    </div>
                    <div className="sheet-field">
                      <label>Strip</label>
                      <input
                        value={sheetInfo.strip}
                        onChange={(e) =>
                          setSheetInfo((prev) => ({
                            ...prev,
                            strip: e.target.value,
                          }))
                        }
                      />
                    </div>
                    <div className="sheet-field">
                      <label>Referee</label>
                      <input
                        value={sheetInfo.referee}
                        onChange={(e) =>
                          setSheetInfo((prev) => ({
                            ...prev,
                            referee: e.target.value,
                          }))
                        }
                      />
                    </div>
                  </div>

                  <div className="grid-wrap">
                    <table className="sheet-table">
                      <thead>
                        <tr>
                          <th>Club</th>
                          <th>Name</th>
                          <th>#</th>
                          {pool.fencers.map((_, idx) => (
                            <th key={`head-${pool.id}-${idx}`}>{idx + 1}</th>
                          ))}
                          <th>V</th>
                          <th>TS</th>
                          <th>TR</th>
                          <th>Ind</th>
                          <th>Win%</th>
                        </tr>
                      </thead>
                      <tbody>
                        {stats.map((fencer) => (
                          <tr key={fencer.id}>
                            <td style={{ textAlign: "left" }}>
                              {fencer.club}
                            </td>
                            <td style={{ textAlign: "left" }}>
                              {fencer.name}
                            </td>
                            <td>{fencer.index}</td>
                            {pool.fencers.map((_, colIdx) => {
                              const rowIndex = fencer.index;
                              const colIndex = colIdx + 1;
                              if (rowIndex === colIndex) {
                                return (
                                  <td key={`${fencer.id}-d-${colIndex}`}>
                                    <span className="diag">—</span>
                                  </td>
                                );
                              }
                              const scoreKey = getScoreKey(
                                pool.id,
                                rowIndex,
                                colIndex
                              );
                              return (
                                <td key={`${fencer.id}-${colIndex}`}>
                                  <input
                                    type="number"
                                    min="0"
                                    value={scores[scoreKey]}
                                    onChange={(e) =>
                                      setScores((prev) => ({
                                        ...prev,
                                        [scoreKey]: e.target.value,
                                      }))
                                    }
                                  />
                                </td>
                              );
                            })}
                            <td>{fencer.wins}</td>
                            <td>{fencer.ts}</td>
                            <td>{fencer.tr}</td>
                            <td>{fencer.ind}</td>
                            <td>{(fencer.winPct * 100).toFixed(0)}%</td>
                          </tr>
                        ))}
                      </tbody>
                    </table>
                  </div>

                  <p className="hint">
                    Enter scores in the row/column grid. A bout is counted once
                    both fencers have scores filled.
                  </p>

                  <h3 style={{ margin: "12px 0 6px", fontSize: "14px" }}>
                    Bout Order
                  </h3>
                  {bouts.map((pair, boutIndex) => {
                    const [aIdx, bIdx] = pair;
                    const aFencer = pool.fencers[aIdx - 1];
                    const bFencer = pool.fencers[bIdx - 1];
                    return (
                      <div key={`${pool.id}-${boutIndex}`} className="bout-row">
                        <span>
                          {boutIndex + 1}. {aIdx} {aFencer?.name || ""}
                          {" vs "}
                          {bIdx} {bFencer?.name || ""}
                        </span>
                      </div>
                    );
                  })}
                </div>
              ))}
            </section>

            <section className="panel">
              <h2>DE Seeding + Tableau</h2>
              {seedings.length === 0 ? (
                <p className="muted">Enter pool results to seed DEs.</p>
              ) : (
                <>
                  <div className="grid-wrap">
                    <table>
                      <thead>
                        <tr>
                          <th>Seed</th>
                          <th>Name</th>
                          <th>Club</th>
                          <th>Pool V</th>
                          <th>Ind</th>
                          <th>TS</th>
                          <th>Win%</th>
                        </tr>
                      </thead>
                      <tbody>
                        {seedings.map((f) => (
                          <tr key={f.id}>
                            <td className="good">{f.deSeed}</td>
                            <td style={{ textAlign: "left" }}>{f.name}</td>
                            <td style={{ textAlign: "left" }}>{f.club}</td>
                            <td>{f.wins}</td>
                            <td>{f.ind}</td>
                            <td>{f.ts}</td>
                            <td>{(f.winPct * 100).toFixed(0)}%</td>
                          </tr>
                        ))}
                      </tbody>
                    </table>
                  </div>

                  <p className="hint">
                    Enter DE scores per match. Winners advance automatically to
                    the next round.
                  </p>

                  <div className="de-rounds">
                    {deRounds.map((round, roundIndex) => (
                      <div key={`round-${round.roundSize}`} className="de-round">
                        <h4>Round of {round.roundSize}</h4>
                        {round.matches.map((match, matchIndex) => {
                          const winner = getWinner(match, deResults);
                          return (
                            <div key={match.id} className="de-match">
                              <div>
                                <span className="de-seed">
                                  M{matchIndex + 1}{" "}
                                  {match.slotA?.seed
                                    ? `#${match.slotA.seed}`
                                    : "—"}
                                </span>
                                <span
                                  className={
                                    winner?.name === match.slotA?.name
                                      ? "de-winner"
                                      : ""
                                  }
                                >
                                  {match.slotA?.name || "BYE"}
                                </span>
                              </div>
                              <input
                                type="number"
                                min="0"
                                placeholder="A"
                                value={deResults[getMatchKey(match.id, "a")]}
                                onChange={(e) =>
                                  setDeResults((prev) => ({
                                    ...prev,
                                    [getMatchKey(match.id, "a")]:
                                      e.target.value,
                                  }))
                                }
                              />
                              <input
                                type="number"
                                min="0"
                                placeholder="B"
                                value={deResults[getMatchKey(match.id, "b")]}
                                onChange={(e) =>
                                  setDeResults((prev) => ({
                                    ...prev,
                                    [getMatchKey(match.id, "b")]:
                                      e.target.value,
                                  }))
                                }
                              />

                              <div>
                                <span className="de-seed">
                                  {match.slotB?.seed
                                    ? `#${match.slotB.seed}`
                                    : "—"}
                                </span>
                                <span
                                  className={
                                    winner?.name === match.slotB?.name
                                      ? "de-winner"
                                      : ""
                                  }
                                >
                                  {match.slotB?.name || "BYE"}
                                </span>
                              </div>
                            </div>
                          );
                        })}
                      </div>
                    ))}
                  </div>
                </>
              )}
            </section>
          </>
        );
      };

      ReactDOM.createRoot(document.getElementById("root")).render(<App />);
    </script>
  </body>
</html>
