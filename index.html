<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Fencing Pool + DE Builder</title>
    <style>
      :root {
        --bg: #0f1115;
        --panel: #171a21;
        --muted: #8f9bb3;
        --text: #eef2ff;
        --accent: #5b8cff;
        --border: #2a2f3a;
        --good: #26c281;
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        background: var(--bg);
        color: var(--text);
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      }
      header {
        padding: 20px 16px 8px;
        border-bottom: 1px solid var(--border);
      }
      h1 {
        margin: 0 0 6px;
        font-size: 22px;
        font-weight: 700;
      }
      p {
        margin: 4px 0;
        color: var(--muted);
        font-size: 13px;
      }
      main {
        padding: 16px;
        display: grid;
        gap: 16px;
      }
      .panel {
        background: var(--panel);
        border: 1px solid var(--border);
        border-radius: 10px;
        padding: 14px;
      }
      .panel h2 {
        margin: 0 0 10px;
        font-size: 16px;
      }
      label {
        display: block;
        font-size: 12px;
        color: var(--muted);
        margin-bottom: 6px;
      }
      textarea,
      input,
      select,
      button {
        width: 100%;
        border-radius: 8px;
        border: 1px solid var(--border);
        background: #0c0f14;
        color: var(--text);
        padding: 8px 10px;
        font-size: 14px;
      }
      textarea {
        min-height: 120px;
        resize: vertical;
      }
      .row {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 10px;
      }
      .hint {
        font-size: 12px;
        color: var(--muted);
        margin-top: 6px;
      }
      .warning {
        color: #ffb14f;
        font-size: 12px;
        margin-top: 6px;
      }
      table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 8px;
      }
      th,
      td {
        border: 1px solid var(--border);
        padding: 6px 6px;
        text-align: center;
        font-size: 12px;
      }
      th {
        background: #10141b;
        font-weight: 600;
        color: var(--muted);
      }
      .pool-card {
        border: 1px solid var(--border);
        border-radius: 10px;
        padding: 10px;
        margin-bottom: 12px;
      }
      .pool-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
      }
      .badge {
        background: #1b2240;
        color: #bcd1ff;
        font-size: 12px;
        padding: 2px 8px;
        border-radius: 999px;
      }
      .bout-row {
        display: grid;
        grid-template-columns: 1fr 64px 64px;
        gap: 6px;
        align-items: center;
        margin-bottom: 6px;
      }
      .bout-row input {
        text-align: center;
      }
      .bout-row span {
        font-size: 12px;
      }
      .inline {
        display: flex;
        gap: 8px;
        align-items: center;
      }
      .inline input[type="checkbox"] {
        width: auto;
      }
      .good {
        color: var(--good);
        font-weight: 600;
      }
      .grid-wrap {
        overflow-x: auto;
      }
      .muted {
        color: var(--muted);
      }
    </style>
  </head>
  <body>
    <header>
      <h1>Fencing Pool + DE Builder</h1>
      <p>Frontend-only pool + DE sheets with bout order, calculations, and seeding.</p>
    </header>
    <main id="root"></main>

    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script type="text/babel">
      const { useMemo, useState, useEffect } = React;

      const DEFAULT_BOUT_ORDER = {
        4: [
          [1, 4],
          [2, 3],
          [1, 3],
          [2, 4],
          [3, 4],
          [1, 2],
        ],
        5: [
          [1, 2],
          [3, 4],
          [5, 1],
          [2, 3],
          [5, 4],
          [1, 3],
          [2, 5],
          [4, 1],
          [3, 5],
          [4, 2],
        ],
        6: [
          [1, 4],
          [2, 5],
          [3, 6],
          [1, 2],
          [3, 5],
          [4, 6],
          [2, 3],
          [1, 5],
          [4, 2],
          [6, 1],
          [3, 4],
          [5, 6],
          [2, 6],
          [3, 1],
          [4, 5],
        ],
        7: [
          [1, 4],
          [2, 5],
          [3, 6],
          [7, 1],
          [4, 5],
          [2, 6],
          [3, 7],
          [1, 5],
          [4, 6],
          [2, 7],
          [3, 1],
          [5, 6],
          [4, 7],
          [1, 2],
          [3, 5],
          [6, 7],
          [2, 4],
          [1, 6],
          [5, 7],
          [3, 4],
          [2, 3],
        ],
        8: [
          [1, 5],
          [2, 6],
          [3, 7],
          [4, 8],
          [1, 2],
          [3, 4],
          [5, 6],
          [7, 8],
          [1, 3],
          [2, 4],
          [5, 7],
          [6, 8],
          [1, 4],
          [2, 3],
          [5, 8],
          [6, 7],
          [1, 6],
          [2, 5],
          [3, 8],
          [4, 7],
          [1, 7],
          [2, 8],
          [3, 5],
          [4, 6],
          [1, 8],
          [2, 7],
          [3, 6],
          [4, 5],
        ],
      };

      const nextPowerOfTwo = (n) => {
        let p = 1;
        while (p < n) p *= 2;
        return p;
      };

      const parseFencers = (text) =>
        text
          .split("\n")
          .map((line) => line.trim())
          .filter(Boolean)
          .map((line, idx) => {
            let name = line;
            let club = "";
            if (line.includes("|")) {
              const [left, right] = line.split("|").map((part) => part.trim());
              name = left || `Fencer ${idx + 1}`;
              club = right || "";
            } else if (line.includes(",")) {
              const [left, right] = line.split(",").map((part) => part.trim());
              name = left || `Fencer ${idx + 1}`;
              club = right || "";
            } else if (line.includes("\t")) {
              const [left, right] = line.split("\t").map((part) => part.trim());
              name = left || `Fencer ${idx + 1}`;
              club = right || "";
            }
            return { id: `f${idx + 1}`, seed: idx + 1, name, club };
          });

      const snakePools = (fencers, poolSize) => {
        if (!fencers.length) return [];
        const poolCount = Math.ceil(fencers.length / poolSize);
        const pools = Array.from({ length: poolCount }, (_, i) => ({
          id: `pool-${i + 1}`,
          label: `Pool ${i + 1}`,
          fencers: [],
        }));
        fencers.forEach((fencer, index) => {
          const row = Math.floor(index / poolCount);
          const posInRow = index % poolCount;
          const poolIndex = row % 2 === 0 ? posInRow : poolCount - 1 - posInRow;
          pools[poolIndex].fencers.push(fencer);
        });
        return pools;
      };

      const parseCustomOrder = (text) =>
        text
          .split("\n")
          .map((line) => line.trim())
          .filter(Boolean)
          .map((line) => {
            const cleaned = line.replace(/[^\d-]/g, "");
            const [a, b] = cleaned.split("-").map((n) => Number(n));
            return Number.isFinite(a) && Number.isFinite(b) ? [a, b] : null;
          })
          .filter(Boolean);

      const buildBoutOrder = (size, customPairs) => {
        if (customPairs && customPairs.length === (size * (size - 1)) / 2) {
          return customPairs;
        }
        return DEFAULT_BOUT_ORDER[size] || [];
      };

      const getScoreKey = (poolId, boutIndex, side) => `${poolId}-${boutIndex}-${side}`;

      const computePoolStats = (pool, bouts, scores) => {
        const stats = pool.fencers.map((fencer, idx) => ({
          ...fencer,
          index: idx + 1,
          wins: 0,
          ts: 0,
          tr: 0,
          bouts: 0,
        }));
        const byIndex = Object.fromEntries(stats.map((f) => [f.index, f]));

        bouts.forEach((pair, boutIndex) => {
          const [aIdx, bIdx] = pair;
          const aScore = Number(scores[getScoreKey(pool.id, boutIndex, "a")]);
          const bScore = Number(scores[getScoreKey(pool.id, boutIndex, "b")]);
          if (!Number.isFinite(aScore) || !Number.isFinite(bScore)) return;
          const a = byIndex[aIdx];
          const b = byIndex[bIdx];
          if (!a || !b) return;
          a.ts += aScore;
          a.tr += bScore;
          b.ts += bScore;
          b.tr += aScore;
          a.bouts += 1;
          b.bouts += 1;
          if (aScore > bScore) a.wins += 1;
          if (bScore > aScore) b.wins += 1;
        });

        return stats.map((f) => ({
          ...f,
          ind: f.ts - f.tr,
          winPct: f.bouts ? f.wins / f.bouts : 0,
        }));
      };

      const buildDeSeedings = (poolStats, promotionPct) => {
        const promotedCount = Math.ceil((poolStats.length * promotionPct) / 100);
        const sorted = [...poolStats].sort((a, b) => {
          if (b.winPct !== a.winPct) return b.winPct - a.winPct;
          if (b.ind !== a.ind) return b.ind - a.ind;
          if (b.ts !== a.ts) return b.ts - a.ts;
          return a.name.localeCompare(b.name);
        });
        return sorted.slice(0, promotedCount).map((f, idx) => ({
          ...f,
          deSeed: idx + 1,
        }));
      };

      const buildDeMatchups = (seedings) => {
        const size = nextPowerOfTwo(seedings.length);
        const getSeed = (seed) => seedings.find((f) => f.deSeed === seed);
        const matchups = [];
        for (let seed = 1; seed <= size / 2; seed += 1) {
          const opponentSeed = size + 1 - seed;
          matchups.push({
            seed,
            opponentSeed,
            a: getSeed(seed),
            b: getSeed(opponentSeed),
            size,
          });
        }
        return { size, matchups };
      };

      const App = () => {
        const [fencerText, setFencerText] = useState("");
        const [poolSize, setPoolSize] = useState(7);
        const [promotionPct, setPromotionPct] = useState(100);
        const [useCustomOrder, setUseCustomOrder] = useState(false);
        const [customOrderText, setCustomOrderText] = useState("");
        const [scores, setScores] = useState({});

        const fencers = useMemo(() => parseFencers(fencerText), [fencerText]);
        const pools = useMemo(() => snakePools(fencers, poolSize), [fencers, poolSize]);
        const customOrder = useMemo(
          () => (useCustomOrder ? parseCustomOrder(customOrderText) : null),
          [useCustomOrder, customOrderText]
        );

        useEffect(() => {
          const nextScores = {};
          pools.forEach((pool) => {
            const bouts = buildBoutOrder(pool.fencers.length, customOrder);
            bouts.forEach((_, boutIndex) => {
              nextScores[getScoreKey(pool.id, boutIndex, "a")] = "";
              nextScores[getScoreKey(pool.id, boutIndex, "b")] = "";
            });
          });
          setScores((prev) => ({ ...nextScores, ...prev }));
        }, [pools, customOrder]);

        const poolSummaries = pools.map((pool) => {
          const bouts = buildBoutOrder(pool.fencers.length, customOrder);
          const stats = computePoolStats(pool, bouts, scores);
          return { pool, bouts, stats };
        });

        const allStats = poolSummaries.flatMap((summary) => summary.stats);
        const seedings = buildDeSeedings(allStats, promotionPct);
        const deTableau = buildDeMatchups(seedings);

        const customOrderExpected =
          poolSize && (poolSize * (poolSize - 1)) / 2;
        const customOrderValid =
          customOrder && customOrder.length === customOrderExpected;

        return (
          <>
            <section className="panel">
              <h2>Fencers</h2>
              <label>One per line. Use "Name | Club" or "Name, Club".</label>
              <textarea
                value={fencerText}
                placeholder={"Alex Smith | Club A\nJamie Lee | Club B"}
                onChange={(e) => setFencerText(e.target.value)}
              />
              <p className="hint">
                Seed order is the input order. Pools use snake placement.
              </p>
            </section>

            <section className="panel">
              <h2>Pool Settings</h2>
              <div className="row">
                <div>
                  <label>Pool size</label>
                  <select
                    value={poolSize}
                    onChange={(e) => setPoolSize(Number(e.target.value))}
                  >
                    {[4, 5, 6, 7, 8].map((size) => (
                      <option key={size} value={size}>
                        {size}
                      </option>
                    ))}
                  </select>
                </div>
                <div>
                  <label>Promotion to DE</label>
                  <select
                    value={promotionPct}
                    onChange={(e) => setPromotionPct(Number(e.target.value))}
                  >
                    <option value={100}>100% (local + most events)</option>
                    <option value={80}>80% (some national events)</option>
                  </select>
                </div>
              </div>
              <div className="inline" style={{ marginTop: "10px" }}>
                <input
                  type="checkbox"
                  checked={useCustomOrder}
                  onChange={(e) => setUseCustomOrder(e.target.checked)}
                />
                <label style={{ margin: 0 }}>
                  Use custom bout order for current pool size
                </label>
              </div>
              {useCustomOrder ? (
                <>
                  <textarea
                    value={customOrderText}
                    placeholder={"1-4\n2-3\n1-3\n2-4\n3-4\n1-2"}
                    onChange={(e) => setCustomOrderText(e.target.value)}
                  />
                  <p className="hint">
                    Expected {customOrderExpected} bouts for pool size {poolSize}.
                  </p>
                  {!customOrderValid && (
                    <p className="warning">
                      Custom order ignored until it matches the expected count.
                    </p>
                  )}
                </>
              ) : (
                <p className="hint">
                  Default order is based on the USA Fencing pool sheet (2019
                  revision).
                </p>
              )}
            </section>

            <section className="panel">
              <h2>Pools</h2>
              {pools.length === 0 && (
                <p className="muted">Add fencers to generate pools.</p>
              )}
              {poolSummaries.map(({ pool, bouts, stats }) => (
                <div key={pool.id} className="pool-card">
                  <div className="pool-header">
                    <strong>{pool.label}</strong>
                    <span className="badge">{pool.fencers.length} fencers</span>
                  </div>

                  <div className="grid-wrap">
                    <table>
                      <thead>
                        <tr>
                          <th>#</th>
                          <th>Name</th>
                          <th>Club</th>
                          <th>V</th>
                          <th>TS</th>
                          <th>TR</th>
                          <th>Ind</th>
                          <th>Win%</th>
                        </tr>
                      </thead>
                      <tbody>
                        {stats.map((fencer) => (
                          <tr key={fencer.id}>
                            <td>{fencer.index}</td>
                            <td style={{ textAlign: "left" }}>
                              {fencer.name}
                            </td>
                            <td style={{ textAlign: "left" }}>
                              {fencer.club}
                            </td>
                            <td>{fencer.wins}</td>
                            <td>{fencer.ts}</td>
                            <td>{fencer.tr}</td>
                            <td>{fencer.ind}</td>
                            <td>{(fencer.winPct * 100).toFixed(0)}%</td>
                          </tr>
                        ))}
                      </tbody>
                    </table>
                  </div>

                  <h3 style={{ margin: "12px 0 6px", fontSize: "14px" }}>
                    Bout Order
                  </h3>
                  {bouts.map((pair, boutIndex) => {
                    const [aIdx, bIdx] = pair;
                    const aFencer = pool.fencers[aIdx - 1];
                    const bFencer = pool.fencers[bIdx - 1];
                    return (
                      <div key={`${pool.id}-${boutIndex}`} className="bout-row">
                        <span>
                          {boutIndex + 1}. {aIdx} {aFencer?.name || ""}
                          {" vs "}
                          {bIdx} {bFencer?.name || ""}
                        </span>
                        <input
                          type="number"
                          min="0"
                          placeholder="A"
                          value={scores[getScoreKey(pool.id, boutIndex, "a")]}
                          onChange={(e) =>
                            setScores((prev) => ({
                              ...prev,
                              [getScoreKey(pool.id, boutIndex, "a")]:
                                e.target.value,
                            }))
                          }
                        />
                        <input
                          type="number"
                          min="0"
                          placeholder="B"
                          value={scores[getScoreKey(pool.id, boutIndex, "b")]}
                          onChange={(e) =>
                            setScores((prev) => ({
                              ...prev,
                              [getScoreKey(pool.id, boutIndex, "b")]:
                                e.target.value,
                            }))
                          }
                        />
                      </div>
                    );
                  })}
                </div>
              ))}
            </section>

            <section className="panel">
              <h2>DE Seeding + First Round</h2>
              {seedings.length === 0 ? (
                <p className="muted">Enter pool results to seed DEs.</p>
              ) : (
                <>
                  <div className="grid-wrap">
                    <table>
                      <thead>
                        <tr>
                          <th>Seed</th>
                          <th>Name</th>
                          <th>Club</th>
                          <th>Pool V</th>
                          <th>Ind</th>
                          <th>TS</th>
                          <th>Win%</th>
                        </tr>
                      </thead>
                      <tbody>
                        {seedings.map((f) => (
                          <tr key={f.id}>
                            <td className="good">{f.deSeed}</td>
                            <td style={{ textAlign: "left" }}>{f.name}</td>
                            <td style={{ textAlign: "left" }}>{f.club}</td>
                            <td>{f.wins}</td>
                            <td>{f.ind}</td>
                            <td>{f.ts}</td>
                            <td>{(f.winPct * 100).toFixed(0)}%</td>
                          </tr>
                        ))}
                      </tbody>
                    </table>
                  </div>

                  <p className="hint">
                    DE opponent formula: (tableau size + 1) - your seed.
                  </p>

                  <div className="grid-wrap">
                    <table>
                      <thead>
                        <tr>
                          <th>Tableau</th>
                          <th>Seed</th>
                          <th>Opponent Seed</th>
                          <th>Match</th>
                        </tr>
                      </thead>
                      <tbody>
                        {deTableau.matchups.map((match) => (
                          <tr key={`${match.seed}-${match.opponentSeed}`}>
                            <td>R{deTableau.size}</td>
                            <td>{match.seed}</td>
                            <td>{match.opponentSeed}</td>
                            <td style={{ textAlign: "left" }}>
                              {match.a
                                ? `${match.a.name}`
                                : "BYE"}{" "}
                              vs{" "}
                              {match.b
                                ? `${match.b.name}`
                                : "BYE"}
                            </td>
                          </tr>
                        ))}
                      </tbody>
                    </table>
                  </div>
                </>
              )}
            </section>
          </>
        );
      };

      ReactDOM.createRoot(document.getElementById("root")).render(<App />);
    </script>
  </body>
</html>
